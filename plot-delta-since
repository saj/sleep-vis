#!/usr/bin/env python3

"""
plot-delta-since plots the difference between adjacent wake->sleep (bed) times.

Usage:

    parse-saa < sleep-export.csv | tac | plot-delta-since

Input events must be presented in ascending chronological order.
"""

import fileinput
import sys
from collections import deque
from datetime import timedelta

import matplotlib.dates as mdates
import matplotlib.pyplot as plt
import numpy as np
import pandas as pd

import _lib
from _lib.ldatetime import SECONDS_IN_DAY, SECONDS_IN_HOUR
from _lib.levent import Event, parse_events
from _lib.litertools import nextnrfull


def main(argv=None):
    args = _lib.parse_args(argv, {
        ("--figsize-height-inches",): {
            "default": _lib.MP_DEFAULT_FIGURE_HEIGHT_INCHES,
        }})

    data = _build_dataframe(fileinput.input(files=args.input))

    plt.ioff()
    plt.switch_backend("Agg")
    plt.style.use("seaborn-darkgrid")

    fig, ax = plt.subplots(dpi=args.dpi,
                           figsize=(args.figsize_width_inches,
                                    args.figsize_height_inches))
    ax.step(data.index, data["delta"], "-", label="Î” bed time")
    ax.plot(data.index, data["sma"], "-", label="SMA (14d)")
    ax.lines[0].set_linewidth(1)
    ax.lines[0].set_alpha(0.5)
    ax.lines[1].set_linewidth(3)
    ax.lines[1].set_alpha(0.5)
    ax.legend()

    xloc = mdates.AutoDateLocator(minticks=3, maxticks=10)
    xfmt = mdates.ConciseDateFormatter(xloc)
    ax.xaxis.set_major_locator(xloc)
    ax.xaxis.set_major_formatter(xfmt)

    @plt.FuncFormatter
    def _format_ytick(v, unused_pos):
        return int(v / SECONDS_IN_HOUR)
    ax.yaxis.set_major_locator(plt.MultipleLocator(4 * SECONDS_IN_HOUR))
    ax.axhline(SECONDS_IN_DAY, color="black", linewidth=1, dashes=(1, 2))
    ax.yaxis.set_major_formatter(_format_ytick)

    fig.tight_layout()
    fig.savefig(args.output)


def _build_dataframe(file):
    df = pd.DataFrame.from_records(
        np.fromiter(_deltas(file),
                    dtype=[("date",  "datetime64[ns]"),
                           ("delta", "uint32")]),
        index="date")
    df["sma"] = df.rolling(window=14)["delta"].mean()
    return df


def _deltas(file):
    for events in nextnrfull(_merge_adjoining_events(file)):
        last_event, next_event = events[0], events[1]
        delta_seconds = (next_event.since - last_event.since).total_seconds()
        yield next_event.since, delta_seconds


def _merge_adjoining_events(file, closeness=timedelta(hours=4)):

    # Two events, a and b, are adjoining if b starts when a ends.
    #
    # How do adjoining events occur in the dataset?
    # I suspect they are an artefact of the following real-world pattern:
    #
    #   An alarm is set to activate after ~8h of sleep.
    #   I go to sleep.
    #   ~8h later, the alarm activates, and is dismissed.  (No snooze.)
    #   -> The first event is recorded.
    #   I sleep some more. :)
    #   Later, after waking naturally without an alarm,
    #   I add a new sleep event to record the additional time spent asleep.
    #   -> The second event is recorded.
    #
    # Such events are almost always perfectly adjoining.
    # The first event ends on the same minute the next event starts.
    #
    # Events are not always perfectly adjoining -- for reasons unknown.
    # We merge an event with its preceding event if they are only separated by
    # a small number of hours.  closeness defines the merge threshold.

    adj = deque()
    for next_event in parse_events(file):
        if not adj:
            adj.append(next_event)
            continue
        last_event = adj[-1]
        if next_event.since - last_event.until <= closeness:
            adj.append(next_event)
            continue
        # not adjacent; flush
        yield Event(since=adj[0].since, until=adj[-1].until)
        adj.clear()
        adj.append(next_event)
        continue
    if adj:
        yield Event(since=adj[0].since, until=adj[-1].until)
        adj.clear()


if __name__ == "__main__":
    sys.exit(main(sys.argv))
